(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{600:function(t,a,s){"use strict";s.r(a);var e=s(14),i=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"数据库连接池基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库连接池基本原理"}},[t._v("#")]),t._v(" 数据库连接池基本原理")]),t._v(" "),a("h4",{attrs:{id:"连接池基本用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接池基本用法"}},[t._v("#")]),t._v(" 连接池基本用法")]),t._v(" "),a("p",[t._v("建立数据库连接是一个比较耗时的工作，定义一个数据库连接的集合（连接池），系统启动后，预先初始化initialSize个连接，放到连接池中。请求到来时，从连接池中获得一个连接使用，用完再次放回到连接池中。当连接池中的连接都被占用时，可以再次从数据库获得新连接放到连接池中，并返回给客户。但不能超过maxActive的设定。如果超过了，就需要进行等待（等待时间不能超过maxWait，如果超过返回超时异常，本次获取连接失败），等待其他用户释放连接放回连接池。")]),t._v(" "),a("h4",{attrs:{id:"连接有效性验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接有效性验证"}},[t._v("#")]),t._v(" 连接有效性验证")]),t._v(" "),a("p",[t._v("和服务器的数据库连接，因为底层tcp网络的原因，可能会失效，所以连接池会启动一个定时任务，定时检测池中每个的不忙的连接是否还有效，检测的办法就是运行一个简单的sql语句[select 1]，看是否在一个很短的时间内有回应。")]),t._v(" "),a("h4",{attrs:{id:"保持空闲连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持空闲连接"}},[t._v("#")]),t._v(" 保持空闲连接")]),t._v(" "),a("p",[t._v("连接池还有一个minidle参数，定义连接池中的最小空闲连接数，连接池会启动一个定时任务定时扫描连接池的连接，如果空闲的连接数大于该值，则关闭多余的连接，反之则创建更多的连接以满足最小空闲连接数要求。\n设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作。")]),t._v(" "),a("h4",{attrs:{id:"保持空闲连接具体做法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持空闲连接具体做法"}},[t._v("#")]),t._v(" 保持空闲连接具体做法")]),t._v(" "),a("p",[t._v("当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)。在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：\n空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；\n空闲时间大于maxEvictableIdleTimeMillis（默认7小时）；\n然也有可能这时数据库中的连接数小于minIdle，这个时候就需要创建新的连接并添加到连接池了。")]),t._v(" "),a("p",[t._v("数据源并不能确保空闲连接一定等于minIdle，可以通过设置timeBetweenEvictionRunsMillis参数调小定时任务的执行间隔，从而控制数据源中空闲连接数更加接近minIdle；")]),t._v(" "),a("h4",{attrs:{id:"空闲连接是如何产生的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空闲连接是如何产生的"}},[t._v("#")]),t._v(" 空闲连接是如何产生的")]),t._v(" "),a("p",[t._v("假设初始时连接池保存了5个连接，并发请求到来时，可能扩充了连接，连接池中的连接可能达到了15个，一段时间后，可能7个被占用，余下的8个连接就成为了空闲连接，超过了minIdle设置的数量，此时定时任务检查到后，就会真正关闭其中的3个。另外一种情况，假设此时连接池中有10个连接，8个被占用，此时定时任务检查到后就会再从数据库申请3个连接放到连接池，使得连接池中的空闲连接数达到5个。")]),t._v(" "),a("h4",{attrs:{id:"一个参考的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个参考的实现"}},[t._v("#")]),t._v(" 一个参考的实现")]),t._v(" "),a("p",[t._v("本实现没有实现保持空闲连接的定时任务")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://github.com/kamibababa/jdbc-pool\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])}),[],!1,null,null,null);a.default=i.exports}}]);