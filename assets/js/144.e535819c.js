(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{601:function(t,e,s){"use strict";s.r(e);var r=s(14),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"git通识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git通识"}},[t._v("#")]),t._v(" git通识")]),t._v(" "),e("p",[t._v("git分为本地仓库和远程仓库")]),t._v(" "),e("p",[t._v("git图形界面工具fork")]),t._v(" "),e("p",[t._v("本地仓库有3个区：")]),t._v(" "),e("p",[t._v("1.工作目录")]),t._v(" "),e("p",[t._v("2.暂存区")]),t._v(" "),e("p",[t._v("3.本地仓库")]),t._v(" "),e("p",[t._v("当工作目录新增文件，修改文件，删除文件后，git add可以提交到暂存区，git restore可以将暂存区内容再次覆盖工作区。git restore --staged撤销暂存区提交。 git commit之后可以将暂存区内容提交到本地仓库。git reset -soft -mixed  -hard 可将本地仓库内容撤销覆盖回暂存区和工作目录。")]),t._v(" "),e("p",[t._v("分支：避免在主分支上提交代码")]),t._v(" "),e("p",[t._v("新功能和改bug都新建一个分支，开发完再merge回主分支。尽量在commit之后，创建新分支，切换分支，因为各个分支之间共享工作目录和暂存区。也可以使用stash将内容保存到临时存储区。")]),t._v(" "),e("p",[t._v("远程仓库：")]),t._v(" "),e("p",[t._v("clone或push后，本地仓库会和远程仓库绑定（set-upstream），建立远程追踪分支。")]),t._v(" "),e("p",[t._v("不能切换到远程追踪分支和操作远程追踪分支。初始时本地仓库和远程追踪仓库分支master分支都指向HEAD。本地持续提交会导致本地仓库超越远程追踪分支，如果此时fetch，远程追踪分支可能前进到远程仓库最新版本。此时就出现了分叉，此时我们可以merge远程追踪分支到本地仓库。而pull等于fetch+merge")])])}),[],!1,null,null,null);e.default=v.exports}}]);